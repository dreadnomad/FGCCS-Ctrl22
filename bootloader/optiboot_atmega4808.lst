
optiboot_atmega4808.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <pre_main>:
/* everything that needs to run VERY early */
void pre_main (void) {
    // Allow convenient way of calling do_spm function - jump table,
    //   so entry to this function will always be here, indepedent
    //    of compilation, features, etc
    __asm__ __volatile__ (
   0:	01 c0       	rjmp	.+2      	; 0x4 <main>
   2:	c1 c0       	rjmp	.+386    	; 0x186 <do_nvmctrl>

00000004 <main>:
    //
    // Optiboot C code makes the following assumptions:
    //  No interrupts will execute
    //  SP points to RAMEND

    __asm__ __volatile__ ("clr __zero_reg__"); // known-zero required by avr-libc
   4:	11 24       	eor	r1, r1
#define RESET_EXTERNAL (RSTCTRL_EXTRF_bm|RSTCTRL_UPDIRF_bm|RSTCTRL_SWRF_bm)
#ifndef FANCY_RESET_LOGIC
    ch = RSTCTRL.RSTFR;   // get reset cause
   6:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    RSTCTRL.RSTFR = ch;   //  and reset them all!
   a:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    if (ch & RSTCTRL_WDRF_bm) {
   e:	83 ff       	sbrs	r24, 3
  10:	04 c0       	rjmp	.+8      	; 0x1a <main+0x16>
	// Start the app.
	__asm__ __volatile__ ("mov r2, %0\n" :: "r" (ch));
  12:	28 2e       	mov	r2, r24
	watchdogConfig(WDT_PERIOD_OFF_gc);
  14:	80 e0       	ldi	r24, 0x00	; 0
  16:	9f d0       	rcall	.+318    	; 0x156 <watchdogConfig>
	__asm__ __volatile__ (
  18:	f3 c0       	rjmp	.+486    	; 0x200 <app>
  1a:	a8 95       	wdr
		);
	}
    }
#endif // Fancy reset cause stuff

    watchdogReset();
  1c:	00 9a       	sbi	0x00, 0	; 0
//    _PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, 0);  // full speed clock

    MYUART_TXPORT.DIR |= MYUART_TXPIN; // set TX pin to output
  1e:	08 9a       	sbi	0x01, 0	; 1
    MYUART_TXPORT.OUT |= MYUART_TXPIN;  // and "1" as per datasheet
  20:	10 92 e2 05 	sts	0x05E2, r1	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7005e2>
#if defined (MYUART_PMUX_VAL)
    MYPMUX_REG = MYUART_PMUX_VAL;  // alternate pinout to use
  24:	80 91 82 12 	lds	r24, 0x1282	; 0x801282 <__TEXT_REGION_LENGTH__+0x701282>
#endif
    if ((FUSE_OSCCFG & FUSE_FREQSEL_gm) == FREQSEL_16MHZ_gc) {
  28:	83 70       	andi	r24, 0x03	; 3
  2a:	81 30       	cpi	r24, 0x01	; 1
  2c:	f9 f4       	brne	.+62     	; 0x6c <__SREG__+0x2d>
  2e:	8c e5       	ldi	r24, 0x5C	; 92
	MYUART.BAUD = BAUD_SETTING_16;
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <__TEXT_REGION_LENGTH__+0x700808>
    } else {
	MYUART.BAUD = BAUD_SETTING_20;
  36:	90 93 09 08 	sts	0x0809, r25	; 0x800809 <__TEXT_REGION_LENGTH__+0x700809>
  3a:	81 e0       	ldi	r24, 0x01	; 1
    }
    MYUART.DBGCTRL = 1;  // run during debug
  3c:	80 93 0b 08 	sts	0x080B, r24	; 0x80080b <__TEXT_REGION_LENGTH__+0x70080b>
  40:	83 e0       	ldi	r24, 0x03	; 3
    MYUART.CTRLC = (USART_CHSIZE_gm & USART_CHSIZE_8BIT_gc);  // Async, Parity Disabled, 1 StopBit
  42:	80 93 07 08 	sts	0x0807, r24	; 0x800807 <__TEXT_REGION_LENGTH__+0x700807>
  46:	10 92 05 08 	sts	0x0805, r1	; 0x800805 <__TEXT_REGION_LENGTH__+0x700805>
    MYUART.CTRLA = 0;  // Interrupts: all off
  4a:	80 ec       	ldi	r24, 0xC0	; 192
    MYUART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
  4c:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <__TEXT_REGION_LENGTH__+0x700806>

    // Set up watchdog to trigger after a bit
    //  (nominally:, 1s for autoreset, longer for manual)
    watchdogConfig(WDTPERIOD);
  50:	88 e0       	ldi	r24, 0x08	; 8
  52:	81 d0       	rcall	.+258    	; 0x156 <watchdogConfig>
	    // Read command terminator, start reply
	    verifySpace();
	    /*
	     * Actually Write the buffer to flash (and wait for it to finish.)
	     */
	    _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
  54:	83 e0       	ldi	r24, 0x03	; 3
  56:	f8 2e       	mov	r15, r24
	ch = getch();
  58:	72 d0       	rcall	.+228    	; 0x13e <getch>
	if(ch == STK_GET_PARAMETER) {
  5a:	81 34       	cpi	r24, 0x41	; 65
	    unsigned char which = getch();
  5c:	91 f4       	brne	.+36     	; 0x82 <__SREG__+0x43>
  5e:	6f d0       	rcall	.+222    	; 0x13e <getch>
  60:	18 2f       	mov	r17, r24
	    verifySpace();
  62:	82 d0       	rcall	.+260    	; 0x168 <verifySpace>
  64:	12 38       	cpi	r17, 0x82	; 130
	    if (which == STK_SW_MINOR) {
  66:	29 f4       	brne	.+10     	; 0x72 <__SREG__+0x33>
  68:	80 e0       	ldi	r24, 0x00	; 0
	    putch(0x00);
  6a:	07 c0       	rjmp	.+14     	; 0x7a <__SREG__+0x3b>
  6c:	83 e7       	ldi	r24, 0x73	; 115
	MYUART.BAUD = BAUD_SETTING_20;
  6e:	90 e0       	ldi	r25, 0x00	; 0
  70:	e0 cf       	rjmp	.-64     	; 0x32 <main+0x2e>
	    } else if (which == STK_SW_MAJOR) {
  72:	89 e0       	ldi	r24, 0x09	; 9
  74:	11 38       	cpi	r17, 0x81	; 129
		putch(0x03);
  76:	09 f0       	breq	.+2      	; 0x7a <__SREG__+0x3b>
  78:	83 e0       	ldi	r24, 0x03	; 3
	}
	else {
	    // This covers the response to commands like STK_ENTER_PROGMODE
	    verifySpace();
	}
	putch(STK_OK);
  7a:	5a d0       	rcall	.+180    	; 0x130 <putch>
  7c:	80 e1       	ldi	r24, 0x10	; 16
  7e:	58 d0       	rcall	.+176    	; 0x130 <putch>
	ch = getch();
  80:	eb cf       	rjmp	.-42     	; 0x58 <__SREG__+0x19>
	else if(ch == STK_SET_DEVICE) {
  82:	82 34       	cpi	r24, 0x42	; 66
  84:	19 f4       	brne	.+6      	; 0x8c <__SREG__+0x4d>
	    getNch(20);
  86:	84 e1       	ldi	r24, 0x14	; 20
	    getNch(5);
  88:	77 d0       	rcall	.+238    	; 0x178 <getNch>
  8a:	f8 cf       	rjmp	.-16     	; 0x7c <__SREG__+0x3d>
	else if(ch == STK_SET_DEVICE_EXT) {
  8c:	85 34       	cpi	r24, 0x45	; 69
	    getNch(5);
  8e:	11 f4       	brne	.+4      	; 0x94 <__SREG__+0x55>
  90:	85 e0       	ldi	r24, 0x05	; 5
	else if(ch == STK_LOAD_ADDRESS) {
  92:	fa cf       	rjmp	.-12     	; 0x88 <__SREG__+0x49>
  94:	85 35       	cpi	r24, 0x55	; 85
	    address.bytes[0] = getch();
  96:	31 f4       	brne	.+12     	; 0xa4 <__SREG__+0x65>
  98:	52 d0       	rcall	.+164    	; 0x13e <getch>
	    address.bytes[1] = getch();
  9a:	c8 2f       	mov	r28, r24
	    verifySpace();
  9c:	50 d0       	rcall	.+160    	; 0x13e <getch>
  9e:	d8 2f       	mov	r29, r24
	else if(ch == STK_UNIVERSAL) {
  a0:	63 d0       	rcall	.+198    	; 0x168 <verifySpace>
  a2:	ec cf       	rjmp	.-40     	; 0x7c <__SREG__+0x3d>
	    getNch(4);
  a4:	86 35       	cpi	r24, 0x56	; 86
  a6:	19 f4       	brne	.+6      	; 0xae <__SREG__+0x6f>
  a8:	84 e0       	ldi	r24, 0x04	; 4
	else if(ch == STK_PROG_PAGE) {
  aa:	66 d0       	rcall	.+204    	; 0x178 <getNch>
  ac:	dd cf       	rjmp	.-70     	; 0x68 <__SREG__+0x29>
	    GETLENGTH(length);
  ae:	84 36       	cpi	r24, 0x64	; 100
  b0:	d1 f4       	brne	.+52     	; 0xe6 <__SREG__+0xa7>
  b2:	45 d0       	rcall	.+138    	; 0x13e <getch>
  b4:	44 d0       	rcall	.+136    	; 0x13e <getch>
	    desttype = getch();
  b6:	18 2f       	mov	r17, r24
  b8:	42 d0       	rcall	.+132    	; 0x13e <getch>
	    if (desttype == 'F') {
  ba:	86 34       	cpi	r24, 0x46	; 70
  bc:	91 f4       	brne	.+36     	; 0xe2 <__SREG__+0xa3>
		address.word += MAPPED_PROGMEM_START;
  be:	d0 5c       	subi	r29, 0xC0	; 192
		*(address.bptr++) = getch();
  c0:	6e 01       	movw	r12, r28
  c2:	21 96       	adiw	r28, 0x01	; 1
  c4:	3c d0       	rcall	.+120    	; 0x13e <getch>
  c6:	f6 01       	movw	r30, r12
  c8:	80 83       	st	Z, r24
	    } while (--length);
  ca:	11 50       	subi	r17, 0x01	; 1
	    verifySpace();
  cc:	c9 f7       	brne	.-14     	; 0xc0 <__SREG__+0x81>
	    _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
  ce:	4c d0       	rcall	.+152    	; 0x168 <verifySpace>
  d0:	fd e9       	ldi	r31, 0x9D	; 157
  d2:	f4 bf       	out	0x34, r31	; 52
	    while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
  d4:	f0 92 00 10 	sts	0x1000, r15	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
  d8:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
		address.word += MAPPED_EEPROM_START;
  dc:	83 70       	andi	r24, 0x03	; 3
  de:	e1 f7       	brne	.-8      	; 0xd8 <__SREG__+0x99>
	else if(ch == STK_READ_PAGE) {
  e0:	cd cf       	rjmp	.-102    	; 0x7c <__SREG__+0x3d>
  e2:	dc 5e       	subi	r29, 0xEC	; 236
	    GETLENGTH(length);
  e4:	ed cf       	rjmp	.-38     	; 0xc0 <__SREG__+0x81>
  e6:	84 37       	cpi	r24, 0x74	; 116
  e8:	89 f4       	brne	.+34     	; 0x10c <__SREG__+0xcd>
	    desttype = getch();
  ea:	29 d0       	rcall	.+82     	; 0x13e <getch>
  ec:	28 d0       	rcall	.+80     	; 0x13e <getch>
	    verifySpace();
  ee:	18 2f       	mov	r17, r24
  f0:	26 d0       	rcall	.+76     	; 0x13e <getch>
	    if (desttype == 'F') {
  f2:	08 2f       	mov	r16, r24
  f4:	39 d0       	rcall	.+114    	; 0x168 <verifySpace>
		address.word += MAPPED_PROGMEM_START;
  f6:	06 34       	cpi	r16, 0x46	; 70
		putch(*(address.bptr++));
  f8:	39 f4       	brne	.+14     	; 0x108 <__SREG__+0xc9>
  fa:	d0 5c       	subi	r29, 0xC0	; 192
  fc:	88 81       	ld	r24, Y
	    } while (--length);
  fe:	21 96       	adiw	r28, 0x01	; 1
 100:	17 d0       	rcall	.+46     	; 0x130 <putch>
 102:	11 50       	subi	r17, 0x01	; 1
		address.word += MAPPED_EEPROM_START;
 104:	d9 f7       	brne	.-10     	; 0xfc <__SREG__+0xbd>
 106:	ba cf       	rjmp	.-140    	; 0x7c <__SREG__+0x3d>
	else if(ch == STK_READ_SIGN) {
 108:	dc 5e       	subi	r29, 0xEC	; 236
 10a:	f8 cf       	rjmp	.-16     	; 0xfc <__SREG__+0xbd>
	    verifySpace();
 10c:	85 37       	cpi	r24, 0x75	; 117
 10e:	51 f4       	brne	.+20     	; 0x124 <__SREG__+0xe5>
	    putch(SIGROW_DEVICEID0);
 110:	2b d0       	rcall	.+86     	; 0x168 <verifySpace>
 112:	80 91 00 11 	lds	r24, 0x1100	; 0x801100 <__TEXT_REGION_LENGTH__+0x701100>
 116:	0c d0       	rcall	.+24     	; 0x130 <putch>
	    putch(SIGROW_DEVICEID1);
 118:	80 91 01 11 	lds	r24, 0x1101	; 0x801101 <__TEXT_REGION_LENGTH__+0x701101>
 11c:	09 d0       	rcall	.+18     	; 0x130 <putch>
 11e:	80 91 02 11 	lds	r24, 0x1102	; 0x801102 <__TEXT_REGION_LENGTH__+0x701102>
	    putch(SIGROW_DEVICEID2);
 122:	ab cf       	rjmp	.-170    	; 0x7a <__SREG__+0x3b>
 124:	81 35       	cpi	r24, 0x51	; 81
	else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
 126:	09 f0       	breq	.+2      	; 0x12a <__SREG__+0xeb>
 128:	bb cf       	rjmp	.-138    	; 0xa0 <__SREG__+0x61>
 12a:	81 e0       	ldi	r24, 0x01	; 1
	    watchdogConfig(WDT_PERIOD_8CLK_gc);
 12c:	14 d0       	rcall	.+40     	; 0x156 <watchdogConfig>
 12e:	b8 cf       	rjmp	.-144    	; 0xa0 <__SREG__+0x61>

00000130 <putch>:
 130:	90 91 04 08 	lds	r25, 0x0804	; 0x800804 <__TEXT_REGION_LENGTH__+0x700804>
    }
}

void putch (char ch) {
    while (0 == (MYUART.STATUS & USART_DREIF_bm))
 134:	95 ff       	sbrs	r25, 5
 136:	fc cf       	rjmp	.-8      	; 0x130 <putch>
	;
    MYUART.TXDATAL = ch;
 138:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
}
 13c:	08 95       	ret

0000013e <getch>:

uint8_t getch (void) {
    uint8_t ch, flags;
    while (!(MYUART.STATUS & USART_RXCIF_bm))
 13e:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <__TEXT_REGION_LENGTH__+0x700804>
 142:	87 ff       	sbrs	r24, 7
 144:	fc cf       	rjmp	.-8      	; 0x13e <getch>
	;
    flags = MYUART.RXDATAH;
 146:	90 91 01 08 	lds	r25, 0x0801	; 0x800801 <__TEXT_REGION_LENGTH__+0x700801>
    ch = MYUART.RXDATAL;
 14a:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x700800>
    if ((flags & USART_FERR_bm) == 0)
 14e:	92 fd       	sbrc	r25, 2
 150:	01 c0       	rjmp	.+2      	; 0x154 <getch+0x16>
	watchdogReset();
 152:	a8 95       	wdr
#ifdef LED_DATA_FLASH
    LED_PORT.IN |= LED;
#endif

    return ch;
}
 154:	08 95       	ret

00000156 <watchdogConfig>:
/*
 * Change the watchdog configuration.
 *  Could be a new timeout, could be off...
 */
void watchdogConfig (uint8_t x) {
    while(WDT.STATUS & WDT_SYNCBUSY_bm)
 156:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__TEXT_REGION_LENGTH__+0x700101>
 15a:	90 fd       	sbrc	r25, 0
 15c:	fc cf       	rjmp	.-8      	; 0x156 <watchdogConfig>
	;  // Busy wait for sycnhronization is required!
    _PROTECTED_WRITE(WDT.CTRLA, x);
 15e:	98 ed       	ldi	r25, 0xD8	; 216
 160:	94 bf       	out	0x34, r25	; 52
 162:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__TEXT_REGION_LENGTH__+0x700100>
}
 166:	08 95       	ret

00000168 <verifySpace>:
    if (getch() != CRC_EOP) {
 168:	ea df       	rcall	.-44     	; 0x13e <getch>
 16a:	80 32       	cpi	r24, 0x20	; 32
 16c:	19 f0       	breq	.+6      	; 0x174 <verifySpace+0xc>
	watchdogConfig(WDT_PERIOD_8CLK_gc);    // shorten WD timeout
 16e:	81 e0       	ldi	r24, 0x01	; 1
 170:	f2 df       	rcall	.-28     	; 0x156 <watchdogConfig>
    putch(STK_INSYNC);
 172:	ff cf       	rjmp	.-2      	; 0x172 <verifySpace+0xa>
 174:	84 e1       	ldi	r24, 0x14	; 20
void getNch (uint8_t count) {
 176:	dc cf       	rjmp	.-72     	; 0x130 <putch>

00000178 <getNch>:
 178:	cf 93       	push	r28
    do getch(); while (--count);
 17a:	c8 2f       	mov	r28, r24
 17c:	e0 df       	rcall	.-64     	; 0x13e <getch>
 17e:	c1 50       	subi	r28, 0x01	; 1
}
 180:	e9 f7       	brne	.-6      	; 0x17c <getNch+0x4>
    verifySpace();
 182:	cf 91       	pop	r28
 184:	f1 cf       	rjmp	.-30     	; 0x168 <verifySpace>

00000186 <do_nvmctrl>:
 *   you could do fill-erase-write sequence with data!=0 in ERASE and
 *   data=0 in WRITE
 */
static void do_nvmctrl(uint16_t address, uint8_t command, uint16_t data)  __attribute__ ((used));
static void do_nvmctrl (uint16_t address, uint8_t command, uint16_t data) {
    _PROTECTED_WRITE(WDT.CTRLA, command);
 186:	88 ed       	ldi	r24, 0xD8	; 216
 188:	84 bf       	out	0x34, r24	; 52
 18a:	60 93 00 01 	sts	0x0100, r22	; 0x800100 <__TEXT_REGION_LENGTH__+0x700100>
    while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
 18e:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
 192:	83 70       	andi	r24, 0x03	; 3
 194:	e1 f7       	brne	.-8      	; 0x18e <do_nvmctrl+0x8>
	; // wait for flash and EEPROM not busy, just in case.
}
 196:	08 95       	ret

Disassembly of section .application:

00000200 <app>:
      __attribute__((naked)) app();
void app() 
{
    uint8_t ch;
    
    ch = RSTCTRL.RSTFR;
 200:	e0 e4       	ldi	r30, 0x40	; 64
 202:	f0 e0       	ldi	r31, 0x00	; 0
 204:	80 81       	ld	r24, Z
    RSTCTRL.RSTFR = ch; // reset causes
 206:	80 83       	st	Z, r24
    *(volatile uint16_t *)(&optiboot_version);   // reference the version
 208:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <__TEXT_REGION_LENGTH__+0x7001fe>
 20c:	90 91 ff 01 	lds	r25, 0x01FF	; 0x8001ff <__TEXT_REGION_LENGTH__+0x7001ff>
    do_nvmctrl(0, NVMCTRL_CMD_PAGEBUFCLR_gc, 0); // reference this function!
 210:	50 e0       	ldi	r21, 0x00	; 0
 212:	40 e0       	ldi	r20, 0x00	; 0
 214:	64 e0       	ldi	r22, 0x04	; 4
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	80 e0       	ldi	r24, 0x00	; 0
 21a:	b5 df       	rcall	.-150    	; 0x186 <do_nvmctrl>
    __asm__ __volatile__ ("jmp 0");    // similar to running off end of memory
 21c:	0c 94 00 00 	jmp	0	; 0x0 <pre_main>
